import io.kotest.core.spec.style.StringSpec
import io.kotest.matchers.doubles.plusOrMinus
import io.kotest.matchers.shouldBe
import nebulosa.alignment.polar.point.three.PolarErrorDetermination
import nebulosa.alignment.polar.point.three.Position
import nebulosa.math.deg
import nebulosa.math.hours
import nebulosa.math.toArcsec
import nebulosa.time.IERS
import nebulosa.time.IERSA
import nebulosa.time.TimeYMDHMS
import nebulosa.time.UTC
import java.nio.file.Path
import kotlin.io.path.inputStream

class ThreePointPolarAlignmentTest : StringSpec() {

    init {
        val iersa = IERSA()
        iersa.load(Path.of("../data/finals2000A.all").inputStream())
        IERS.attach(iersa)

        // Based on logs generated by N.I.N.A. using Telescope Simulator for .NET and Sky Simulator (ASCOM).
        // https://sourceforge.net/projects/sky-simulator/

        "perfectly aligned" {
            val position1 = Position("05:35:18".hours, "-05 23 26".deg, LNG, SLAT, UTC(TimeYMDHMS(2024, 2, 10, 22, 58, 42.4979)))
            position1.vector[0] shouldBe (0.301851589038 plusOrMinus 1e-4)
            position1.vector[1] shouldBe (-0.0681426041296783 plusOrMinus 1e-4)
            position1.vector[2] shouldBe (0.950916507216938 plusOrMinus 1e-4)

            val position2 = Position("04:54:45".hours, "-05 24 50".deg, LNG, SLAT, UTC(TimeYMDHMS(2024, 2, 10, 22, 58, 58.1655)))
            position2.vector[0] shouldBe (0.300426130373811 plusOrMinus 1e-4)
            position2.vector[1] shouldBe (0.108903442814494 plusOrMinus 1e-4)
            position2.vector[2] shouldBe (0.947567507005051 plusOrMinus 1e-4)

            val position3 = Position("04:14:08".hours, "-05 26 10".deg, LNG, SLAT, UTC(TimeYMDHMS(2024, 2, 10, 22, 59, 13.3739)))
            position3.vector[0] shouldBe (0.286747300379159 plusOrMinus 1e-4)
            position3.vector[1] shouldBe (0.282671401982864 plusOrMinus 1e-4)
            position3.vector[2] shouldBe (0.915353955705828 plusOrMinus 1e-4)

            val pe = PolarErrorDetermination(position1, position2, position3, LNG, SLAT)
            val (az, alt) = pe.compute()

            // Calculated Error: Az: -00° 00' 04", Alt: -00° 00' 07", Tot: 00° 00' 08"
            az.toArcsec shouldBe (-4.0 plusOrMinus 2.5)
            alt.toArcsec shouldBe (-7.0 plusOrMinus 2.5)
        }
        "bad southern polar aligned" {
            val position1 = Position("05:35:29".hours, "-05 23 44".deg, LNG, SLAT, UTC(TimeYMDHMS(2024, 2, 11, 1, 2, 28.0693)))
            position1.vector[0] shouldBe (0.260120895582042 plusOrMinus 1e-4)
            position1.vector[1] shouldBe (0.452793316696993 plusOrMinus 1e-4)
            position1.vector[2] shouldBe (0.852827844313337 plusOrMinus 1e-4)

            val position2 = Position("04:54:48".hours, "-05 23 16".deg, LNG, SLAT, UTC(TimeYMDHMS(2024, 2, 11, 1, 2, 43.0120)))
            position2.vector[0] shouldBe (0.223679240068826 plusOrMinus 1e-4)
            position2.vector[1] shouldBe (0.603179137475884 plusOrMinus 1e-4)
            position2.vector[2] shouldBe (0.765599455117414 plusOrMinus 1e-4)

            val position3 = Position("04:14:05".hours, "-05 22 47".deg, LNG, SLAT, UTC(TimeYMDHMS(2024, 2, 11, 1, 2, 57.8800)))
            position3.vector[0] shouldBe (0.177343985686423 plusOrMinus 1e-4)
            position3.vector[1] shouldBe (0.734426214459154 plusOrMinus 1e-4)
            position3.vector[2] shouldBe (0.65510857592925 plusOrMinus 1e-4)

            val pe = PolarErrorDetermination(position1, position2, position3, LNG, SLAT)
            val (az, alt) = pe.compute()

            // Calculated Error: Az: 00° 10' 10", Alt: 00° 04' 41", Tot: 00° 11' 11"
            az.toArcsec shouldBe (610.0 plusOrMinus 7.0)
            alt.toArcsec shouldBe (281.0 plusOrMinus 7.0)
        }
        "bad northern polar aligned" {
            val position1 = Position("05:35:35".hours, "-05 32 31".deg, LNG, NLAT, UTC(TimeYMDHMS(2024, 2, 11, 1, 19, 31.1390)))
            position1.vector[0] shouldBe (-0.420977957462894 plusOrMinus 1e-4)
            position1.vector[1] shouldBe (0.517127315719859 plusOrMinus 1e-4)
            position1.vector[2] shouldBe (0.745222717492391 plusOrMinus 1e-4)

            val position2 = Position("04:54:49".hours, "-05 34 43".deg, LNG, NLAT, UTC(TimeYMDHMS(2024, 2, 11, 1, 19, 46.2383)))
            position2.vector[0] shouldBe (-0.379893065189774 plusOrMinus 1e-4)
            position2.vector[1] shouldBe (0.660293278184844 plusOrMinus 1e-4)
            position2.vector[2] shouldBe (0.647837978050554 plusOrMinus 1e-4)

            val position3 = Position("04:13:55".hours, "-05 36 32".deg, LNG, NLAT, UTC(TimeYMDHMS(2024, 2, 11, 1, 20, 1.6394)))
            position3.vector[0] shouldBe (-0.329258727296886 plusOrMinus 1e-4)
            position3.vector[1] shouldBe (0.782693400663722 plusOrMinus 1e-4)
            position3.vector[2] shouldBe (0.528185318857211 plusOrMinus 1e-4)

            val pe = PolarErrorDetermination(position1, position2, position3, LNG, NLAT)
            val (az, alt) = pe.compute()

            // Calculated Error: Az: -00° 09' 58", Alt: 00° 04' 51", Tot: 00° 11' 05"
            az.toArcsec shouldBe (-598.0 plusOrMinus 7.0)
            alt.toArcsec shouldBe (291.0 plusOrMinus 7.0)
        }
    }

    companion object {

        @JvmStatic private val SLAT = "-023".deg
        @JvmStatic private val NLAT = "+023".deg
        @JvmStatic private val LNG = "-045".deg
    }
}
